// Code generated by MockGen. DO NOT EDIT.
// Source: condition.check.go

// Package mock is a generated GoMock package.
package mock

import (
	gomock "github.com/golang/mock/gomock"
	dynamodb "github.com/kadekutama/dynamodb"
	reflect "reflect"
)

// MockConditionCheck is a mock of ConditionCheck interface
type MockConditionCheck struct {
	ctrl     *gomock.Controller
	recorder *MockConditionCheckMockRecorder
}

// MockConditionCheckMockRecorder is the mock recorder for MockConditionCheck
type MockConditionCheckMockRecorder struct {
	mock *MockConditionCheck
}

// NewMockConditionCheck creates a new mock instance
func NewMockConditionCheck(ctrl *gomock.Controller) *MockConditionCheck {
	mock := &MockConditionCheck{ctrl: ctrl}
	mock.recorder = &MockConditionCheckMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockConditionCheck) EXPECT() *MockConditionCheckMockRecorder {
	return m.recorder
}

// Range mocks base method
func (m *MockConditionCheck) Range(rangeKey string, value interface{}) dynamodb.ConditionCheck {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Range", rangeKey, value)
	ret0, _ := ret[0].(dynamodb.ConditionCheck)
	return ret0
}

// Range indicates an expected call of Range
func (mr *MockConditionCheckMockRecorder) Range(rangeKey, value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Range", reflect.TypeOf((*MockConditionCheck)(nil).Range), rangeKey, value)
}

// If mocks base method
func (m *MockConditionCheck) If(expr string, args ...interface{}) dynamodb.ConditionCheck {
	m.ctrl.T.Helper()
	varargs := []interface{}{expr}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "If", varargs...)
	ret0, _ := ret[0].(dynamodb.ConditionCheck)
	return ret0
}

// If indicates an expected call of If
func (mr *MockConditionCheckMockRecorder) If(expr interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{expr}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "If", reflect.TypeOf((*MockConditionCheck)(nil).If), varargs...)
}

// IfExists mocks base method
func (m *MockConditionCheck) IfExists() dynamodb.ConditionCheck {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IfExists")
	ret0, _ := ret[0].(dynamodb.ConditionCheck)
	return ret0
}

// IfExists indicates an expected call of IfExists
func (mr *MockConditionCheckMockRecorder) IfExists() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IfExists", reflect.TypeOf((*MockConditionCheck)(nil).IfExists))
}

// IfNotExists mocks base method
func (m *MockConditionCheck) IfNotExists() dynamodb.ConditionCheck {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IfNotExists")
	ret0, _ := ret[0].(dynamodb.ConditionCheck)
	return ret0
}

// IfNotExists indicates an expected call of IfNotExists
func (mr *MockConditionCheckMockRecorder) IfNotExists() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IfNotExists", reflect.TypeOf((*MockConditionCheck)(nil).IfNotExists))
}
